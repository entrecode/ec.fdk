import { writeFileSync } from "node:fs";
import { resolve } from "node:path";
import { schemaTypeToTS } from "./schema-types";
import { getSchema } from "../lib/entries";
import { dmList, modelList } from "../lib/admin";

export async function typegen(opts: {
  dm: string;
  env: string;
  out: string;
  token: string;
}) {
  const { dm, env, out, token } = opts;

  // 1. Find the DM UUID from shortID
  process.stderr.write(`Looking up datamanager ${dm}...\n`);
  const dms = await dmList({ env, token, options: { shortID: dm } });
  if (!dms.items.length) {
    process.stderr.write(`Error: Datamanager with shortID "${dm}" not found.\n`);
    process.exit(2);
  }
  const dmID = dms.items[0].dataManagerID;

  // 2. Fetch all models
  process.stderr.write(`Fetching models...\n`);
  const models = await modelList({ env, token, dmID, options: { size: 100 } });
  if (!models.items.length) {
    process.stderr.write(`No models found for datamanager ${dm}.\n`);
    process.exit(2);
  }

  // 3. For each model, fetch schema and generate types
  const registryEntries: string[] = [];

  for (const model of models.items) {
    const modelName = model.title;
    process.stderr.write(`  ${modelName}...\n`);

    try {
      const schema = await getSchema({
        env,
        dmShortID: dm,
        model: modelName,
        withMetadata: false,
      });

      const fields: string[] = [];
      for (const [field, def] of Object.entries(schema as Record<string, any>)) {
        const tsType = schemaTypeToTS[def.type] || "unknown";
        const optional = !def.required;
        const sep = optional ? "?: " : ": ";
        const nullable = optional ? " | null" : "";
        fields.push(`      ${field}${sep}${tsType}${nullable};`);
      }

      // Use a safe identifier: replace non-alphanumeric with underscores
      const body = fields.join("\n");
      registryEntries.push(`    "${modelName}": {\n${body}\n    };`);
    } catch (e: any) {
      process.stderr.write(`  Warning: could not fetch schema for ${modelName}: ${e.message}\n`);
    }
  }

  if (!registryEntries.length) {
    process.stderr.write(`No schemas could be fetched.\n`);
    process.exit(2);
  }

  // 4. Generate .d.ts file
  // The top-level `export {}` makes this a module file, so `declare module`
  // performs module augmentation (extending ec.fdk's types) rather than
  // creating an ambient module declaration (which would replace them).
  const content = `// Generated by ec.fdk typegen â€” do not edit manually
// To override field types (e.g. JSON fields), augment ModelOverrides in a separate file.
export {};
declare module "ec.fdk" {
  interface ModelRegistry {
${registryEntries.join("\n")}
  }
}
`;

  const outPath = resolve(out);
  writeFileSync(outPath, content, "utf-8");
  process.stderr.write(`\nGenerated ${outPath} with ${registryEntries.length} model(s).\n`);
}
