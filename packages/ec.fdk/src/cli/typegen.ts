import { writeFileSync } from "node:fs";
import { resolve } from "node:path";
import { schemaTypeToTS } from "./schema-types";
import { getSchema } from "../lib/entries";
import { dmList, modelList } from "../lib/admin";

export async function typegen(opts: {
  dm: string;
  env: string;
  out: string;
  token: string;
  models?: string[];
}) {
  const { dm, env, out, token, models: includeModels } = opts;

  // 1. Find the DM UUID from shortID
  process.stderr.write(`Looking up datamanager ${dm}...\n`);
  const dms = await dmList({ env, token, options: { shortID: dm } });
  if (!dms.items.length) {
    process.stderr.write(`Error: Datamanager with shortID "${dm}" not found.\n`);
    process.exit(2);
  }
  const dmID = dms.items[0].dataManagerID;

  // 2. Fetch models (filter server-side via title if --models is given)
  process.stderr.write(`Fetching models...\n`);
  const listOptions: Record<string, any> = { size: 100 };
  if (includeModels?.length) {
    listOptions.title = includeModels.join(",");
  }
  const models = await modelList({ env, token, dmID, options: listOptions });
  if (!models.items.length) {
    process.stderr.write(`No models found${includeModels?.length ? " matching --models filter" : ""} for datamanager ${dm}.\n`);
    process.exit(2);
  }

  // Warn about requested models that weren't found
  if (includeModels?.length) {
    const found = new Set(models.items.map((m: any) => m.title));
    for (const name of includeModels) {
      if (!found.has(name)) {
        process.stderr.write(`Warning: model "${name}" not found in datamanager.\n`);
      }
    }
  }

  process.stderr.write(`Generating types for ${models.items.length} model(s)...\n`);

  // 3. For each model, fetch schema and generate types
  const registryEntries: string[] = [];
  const generatedModelNames: string[] = [];

  for (const model of models.items) {
    const modelName = model.title;
    process.stderr.write(`  ${modelName}...\n`);

    try {
      const schema = await getSchema({
        env,
        dmShortID: dm,
        model: modelName,
        withMetadata: false,
      });

      const fields: string[] = [];
      for (const [field, def] of Object.entries(schema as Record<string, any>)) {
        const tsType = schemaTypeToTS[def.type] || "unknown";
        const optional = !def.required;
        const sep = optional ? "?: " : ": ";
        const nullable = optional ? " | null" : "";
        fields.push(`      ${field}${sep}${tsType}${nullable}; // ${def.type}`);
      }

      // Use a safe identifier: replace non-alphanumeric with underscores
      const body = fields.join("\n");
      registryEntries.push(`    "${modelName}": {\n${body}\n    };`);
      generatedModelNames.push(modelName);
    } catch (e: any) {
      process.stderr.write(`  Warning: could not fetch schema for ${modelName}: ${e.message}\n`);
    }
  }

  if (!registryEntries.length) {
    process.stderr.write(`No schemas could be fetched.\n`);
    process.exit(2);
  }

  // 4. Generate .d.ts file
  // The top-level `export {}` makes this a module file, so `declare module`
  // performs module augmentation (extending ec.fdk's types) rather than
  // creating an ambient module declaration (which would replace them).

  // Build the regeneration command
  const cmdParts = ["ec.fdk typegen", `--dm ${dm}`, `--env ${env}`];
  if (out !== `./ec.fdk.generated.${dm}.d.ts`) cmdParts.push(`--out ${out}`);
  if (includeModels?.length) cmdParts.push(`--models ${includeModels.join(",")}`);
  const cmd = cmdParts.join(" ");

  const header = [
    `// Generated by ec.fdk typegen â€” do not edit manually`,
    `// Regenerate: ${cmd}`,
    `//`,
    `// Models (${generatedModelNames.length}): ${generatedModelNames.join(", ")}`,
    `//`,
    `// To override field types (e.g. JSON fields), augment ModelOverrides in a separate file.`,
  ].join("\n");

  const content = `${header}
export {};
declare module "ec.fdk" {
  interface ModelRegistry {
${registryEntries.join("\n")}
  }
}
`;

  const outPath = resolve(out);
  writeFileSync(outPath, content, "utf-8");
  process.stderr.write(`\nGenerated ${outPath} with ${registryEntries.length} model(s).\n`);
}
